"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeUndefinedStepDiagnostic = exports.getGherkinDiagnostics = void 0;
var gherkin_1 = require("@cucumber/gherkin");
var gherkin_utils_1 = require("@cucumber/gherkin-utils");
var vscode_languageserver_types_1 = require("vscode-languageserver-types");
var parseGherkinDocument_js_1 = require("../gherkin/parseGherkinDocument.js");
var constants_js_1 = require("./constants.js");
// https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#diagnostic
function getGherkinDiagnostics(gherkinSource, expressions) {
    var e_1, _a;
    var lines = gherkinSource.split(/\r?\n/);
    var _b = (0, parseGherkinDocument_js_1.parseGherkinDocument)(gherkinSource), gherkinDocument = _b.gherkinDocument, error = _b.error;
    var diagnostics = [];
    var errors = error instanceof gherkin_1.Errors.CompositeParserException ? error.errors : error ? [error] : [];
    try {
        for (var errors_1 = __values(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {
            var error_1 = errors_1_1.value;
            if (error_1 instanceof gherkin_1.Errors.GherkinException) {
                var line = error_1.location.line - 1;
                var character = error_1.location.column !== undefined ? error_1.location.column - 1 : 0;
                var diagnostic = {
                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
                    range: {
                        start: {
                            line: line,
                            character: character,
                        },
                        end: {
                            line: line,
                            character: lines[line].length,
                        },
                    },
                    message: error_1.message,
                    source: 'Cucumber',
                };
                diagnostics.push(diagnostic);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return)) _a.call(errors_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (!(gherkinDocument === null || gherkinDocument === void 0 ? void 0 : gherkinDocument.feature)) {
        return diagnostics;
    }
    var inScenarioOutline = false;
    var dialect = gherkin_1.dialects[gherkinDocument.feature.language];
    var noStars = function (keyword) { return keyword !== '* '; };
    var codeKeywords = __spreadArray(__spreadArray(__spreadArray([], __read(dialect.given), false), __read(dialect.when), false), __read(dialect.then), false).filter(noStars);
    var snippetKeyword = dialect.given.filter(noStars)[0];
    return (0, gherkin_utils_1.walkGherkinDocument)(gherkinDocument, diagnostics, {
        scenario: function (scenario, diagnostics) {
            inScenarioOutline = (scenario.examples || []).length > 0;
            return diagnostics;
        },
        step: function (step, diagnostics) {
            if (inScenarioOutline) {
                return diagnostics;
            }
            if (codeKeywords.includes(step.keyword)) {
                snippetKeyword = step.keyword;
            }
            if (isUndefined(step.text, expressions) && step.location.column !== undefined) {
                var line = step.location.line - 1;
                var character = step.location.column - 1 + step.keyword.length;
                var diagnostic = makeUndefinedStepDiagnostic(line, character, step.keyword, step.text, snippetKeyword);
                return diagnostics.concat(diagnostic);
            }
            return diagnostics;
        },
    });
}
exports.getGherkinDiagnostics = getGherkinDiagnostics;
function makeUndefinedStepDiagnostic(line, character, stepKeyword, stepText, snippetKeyword) {
    return {
        severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,
        range: {
            start: {
                line: line,
                character: character,
            },
            end: {
                line: line,
                character: character + stepText.length,
            },
        },
        message: "Undefined step: ".concat(stepText),
        source: 'Cucumber',
        code: constants_js_1.diagnosticCodeUndefinedStep,
        codeDescription: {
            href: 'https://cucumber.io/docs/cucumber/step-definitions/',
        },
        data: {
            snippetKeyword: snippetKeyword,
            stepText: stepText,
        },
    };
}
exports.makeUndefinedStepDiagnostic = makeUndefinedStepDiagnostic;
function isUndefined(stepText, expressions) {
    var e_2, _a;
    try {
        for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
            var expression = expressions_1_1.value;
            if (expression.match(stepText))
                return false;
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return true;
}
//# sourceMappingURL=getGherkinDiagnostics.js.map