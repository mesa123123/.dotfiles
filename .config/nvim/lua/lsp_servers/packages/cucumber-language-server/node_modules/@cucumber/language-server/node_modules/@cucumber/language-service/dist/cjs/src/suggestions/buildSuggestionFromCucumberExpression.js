"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSuggestionFromCucumberExpression = void 0;
var cucumber_expressions_1 = require("@cucumber/cucumber-expressions");
var helpers_js_1 = require("./helpers.js");
function buildSuggestionFromCucumberExpression(expression, registry, parameterChoices) {
    try {
        var compiledSegments = compile(expression.ast, registry, parameterChoices);
        var segments = flatten(compiledSegments);
        return {
            label: expression.source,
            segments: segments,
            matched: true,
        };
    }
    catch (err) {
        err.message += "\nUnable to compile Cucumber Expression \"".concat(expression.source, "\"\nPlease submit an issue at https://github.com/cucumber/language-service/issues\n");
        throw err;
    }
}
exports.buildSuggestionFromCucumberExpression = buildSuggestionFromCucumberExpression;
function flatten(cr) {
    if (typeof cr === 'string')
        return [cr];
    return cr.reduce(function (prev, curr) {
        var last = prev[prev.length - 1];
        if (typeof curr === 'string') {
            if (typeof last === 'string') {
                return prev.slice(0, prev.length - 1).concat([last + curr]);
            }
            else {
                return prev.concat(curr);
            }
        }
        else {
            var x = curr.flatMap(function (e) {
                if (typeof e === 'string')
                    return e;
                var e0 = e[0];
                if (!(typeof e0 === 'string'))
                    throw new Error('Unexpected array: ' + JSON.stringify(e));
                return e0;
            });
            return prev.concat([x]);
        }
    }, []);
}
function compile(node, registry, parameterChoices) {
    switch (node.type) {
        case cucumber_expressions_1.NodeType.text:
            return node.text();
        case cucumber_expressions_1.NodeType.optional:
            return compileOptional(node);
        case cucumber_expressions_1.NodeType.alternation:
            return compileAlternation(node, registry, parameterChoices);
        case cucumber_expressions_1.NodeType.alternative:
            return compileAlternative(node, registry, parameterChoices);
        case cucumber_expressions_1.NodeType.parameter:
            return compileParameter(node, registry, parameterChoices);
        case cucumber_expressions_1.NodeType.expression:
            return compileExpression(node, registry, parameterChoices);
        default:
            // Can't happen as long as the switch case is exhaustive
            throw new Error(node.type);
    }
}
function compileOptional(node) {
    if (node.nodes === undefined)
        throw new Error('No optional');
    return [node.nodes.map(function (node) { return node.text(); }).join('')];
}
function compileAlternation(node, registry, parameterChoices) {
    return (node.nodes || []).map(function (node) { return compile(node, registry, parameterChoices); });
}
function compileAlternative(node, registry, parameterChoices) {
    return (node.nodes || []).map(function (node) { return compile(node, registry, parameterChoices); });
}
function compileParameter(node, registry, parameterChoices) {
    var parameterType = registry.lookupByTypeName(node.text());
    if (parameterType === undefined)
        throw new Error("No parameter type named ".concat(node.text()));
    var key = (0, helpers_js_1.makeKey)(parameterType);
    return parameterChoices[key] || defaultParameterChoices(parameterType) || [''];
}
function compileExpression(node, registry, parameterChoices) {
    return (node.nodes || []).reduce(function (prev, curr) {
        var child = compile(curr, registry, parameterChoices);
        // If we have an optional, we'll create two choice segments - one with and one without the optional
        if (curr.type === cucumber_expressions_1.NodeType.optional) {
            var last = prev[prev.length - 1];
            if (!Array.isArray(child)) {
                throw new Error("Expected an array, but was ".concat(JSON.stringify(child)));
            }
            if (typeof last !== 'string' || last.trim() === '') {
                return prev.concat(child[0]);
            }
            return prev.slice(0, prev.length - 1).concat([[last, last + child[0]]]);
        }
        else {
            return prev.concat([child]);
        }
    }, []);
}
function defaultParameterChoices(parameterType) {
    // @ts-ignore
    if (parameterType.type === Number) {
        return ['0'];
    }
    return ['?'];
}
//# sourceMappingURL=buildSuggestionFromCucumberExpression.js.map