import { CucumberExpressionGenerator } from '@cucumber/cucumber-expressions';
import { CodeActionKind, CreateFile, TextDocumentEdit, TextEdit, VersionedTextDocumentIdentifier, } from 'vscode-languageserver-types';
import { getLanguage } from '../language/languages.js';
import { diagnosticCodeUndefinedStep } from './constants.js';
import { stepDefinitionSnippet } from './snippet/stepDefinitionSnippet.js';
/**
 * Generates LSP code actions for inserting a new Step Definition snippet
 *
 * @param diagnostics all the diagnostics
 * @param link where the snippet should be added
 * @param relativePath the relative path from the workspace root
 * @param createFile true if link.targetUri does not exist
 * @param mustacheTemplate template to generae the snippet
 * @param languageName the name of the language we're generating for
 * @param registry parameter types
 */
export function getGenerateSnippetCodeAction(diagnostics, link, relativePath, createFile, mustacheTemplate, languageName, registry) {
    var _a, _b;
    const undefinedStepDiagnostic = diagnostics.find((d) => d.code === diagnosticCodeUndefinedStep);
    const language = getLanguage(languageName);
    const snippetKeyword = (_a = undefinedStepDiagnostic === null || undefinedStepDiagnostic === void 0 ? void 0 : undefinedStepDiagnostic.data) === null || _a === void 0 ? void 0 : _a.snippetKeyword;
    const stepText = (_b = undefinedStepDiagnostic === null || undefinedStepDiagnostic === void 0 ? void 0 : undefinedStepDiagnostic.data) === null || _b === void 0 ? void 0 : _b.stepText;
    if (!undefinedStepDiagnostic || !stepText) {
        return null;
    }
    const generator = new CucumberExpressionGenerator(() => registry.parameterTypes);
    const generatedExpressions = generator.generateExpressions(stepText);
    const snippet = stepDefinitionSnippet(snippetKeyword, generatedExpressions, mustacheTemplate || language.defaultSnippetTemplate, language.snippetParameters);
    const documentChanges = [];
    if (createFile) {
        documentChanges.push(CreateFile.create(link.targetUri, {
            ignoreIfExists: true,
            overwrite: true,
        }));
    }
    documentChanges.push(TextDocumentEdit.create(VersionedTextDocumentIdentifier.create(link.targetUri, 0), [
        TextEdit.replace(link.targetRange, snippet),
    ]));
    return {
        title: `Define in ${relativePath}`,
        diagnostics: [undefinedStepDiagnostic],
        kind: CodeActionKind.QuickFix,
        edit: {
            documentChanges,
        },
        isPreferred: true,
    };
}
//# sourceMappingURL=getGenerateSnippetCodeAction.js.map