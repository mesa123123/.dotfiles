"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toStringOrRegExp = exports.tsxLanguage = void 0;
var helpers_js_1 = require("./helpers.js");
var SourceAnalyzer_js_1 = require("./SourceAnalyzer.js");
exports.tsxLanguage = {
    toParameterTypeName: function (node) {
        return (0, helpers_js_1.childrenToString)(node, helpers_js_1.NO_QUOTES);
    },
    toParameterTypeRegExps: function (node) {
        return toRegExps(node);
    },
    toStepDefinitionExpression: function (node) {
        return toStringOrRegExp(node);
    },
    defineParameterTypeQueries: [
        "\n(call_expression\n  function: (identifier) @function-name\n  arguments: (arguments\n    (object\n      [\n        (\n          (pair\n            key: (property_identifier) @name-key\n            value: (string) @name\n          )\n          (pair\n            key: (property_identifier) @regexp-key\n            value: [\n              (regex) \n              (string) \n              (array\n                [\n                  (regex) \n                  (string) \n                ]\n              )\n            ] @expression\n          )\n        )\n        (\n          (pair\n            key: (property_identifier) @regexp-key\n            value: [\n              (regex) \n              (string) \n              (array\n                [\n                  (regex) \n                  (string) \n                ]\n              )\n            ] @expression\n          )\n          (pair\n            key: (property_identifier) @name-key\n            value: (string) @name\n          )\n        )\n      ]\n    )\n  )\n  (#eq? @function-name \"defineParameterType\")\n  (#eq? @name-key \"name\")\n  (#eq? @regexp-key \"regexp\")\n) @root\n",
    ],
    defineStepDefinitionQueries: [
        "\n(call_expression\n  function: (identifier) @function-name\n  arguments: (arguments\n    [\n      (string) @expression\n      (regex) @expression\n      (template_string) @expression\n    ]\n  )\n  (#match? @function-name \"Given|When|Then\")\n) @root\n",
    ],
    snippetParameters: {
        int: { type: 'number' },
        float: { type: 'number' },
        word: { type: 'string' },
        string: { type: 'string', name: 's' },
        double: { type: 'number' },
        bigdecimal: { type: 'string', name: 'bigDecimal' },
        byte: { type: 'number' },
        short: { type: 'number' },
        long: { type: 'number' },
        biginteger: { type: 'BigInt', name: 'bigInt' },
        '': { type: 'unknown', name: 'arg' },
    },
    defaultSnippetTemplate: "\n{{ keyword }}('{{ expression }}', ({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}: {{ type }}{{ /parameters }}) => {\n  // {{ blurb }}\n})\n",
};
function toRegExps(node) {
    if (node === null)
        throw new Error('node cannot be null');
    switch (node.type) {
        case 'regex':
        case 'string':
            return toStringOrRegExp(node);
        case 'array':
            return (0, helpers_js_1.filter)(node, function (child) { return child.type === 'regex'; }).map(toStringOrRegExp);
        default:
            throw new Error("Unexpected type: ".concat(node.type));
    }
}
function toStringOrRegExp(node) {
    switch (node.type) {
        case 'regex': {
            var flags = '';
            var flag = void 0;
            var s = node.text;
            for (var i = s.length - 1; (flag = s[i]) !== '/'; i--) {
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags
                flags = "".concat(flags).concat(flag);
            }
            var source = node.children
                .filter(function (child) { return child.type === 'regex_pattern'; })
                .map(function (node) { return node.text; })
                .join('');
            return new RegExp(unescapeString(source), flags);
        }
        case 'string':
            return unescapeString((0, helpers_js_1.childrenToString)(node, helpers_js_1.NO_QUOTES));
        case 'template_string': {
            var substitutions = node.children.filter(function (node) { return node.type === 'template_substitution'; });
            if (substitutions.length > 0) {
                // Can't handle template strings with substitutions.
                return SourceAnalyzer_js_1.NO_EXPRESSION;
            }
            return node.text.slice(1, node.text.length - 1);
        }
        default:
            throw new Error("Unexpected type: ".concat(node.type));
    }
}
exports.toStringOrRegExp = toStringOrRegExp;
function unescapeString(s) {
    return s.replace(/\\'/g, "'").replace(/\\"/g, '"');
}
//# sourceMappingURL=tsxLanguage.js.map