"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGherkinCompletionItems = void 0;
var vscode_languageserver_types_1 = require("vscode-languageserver-types");
var helpers_js_1 = require("./helpers.js");
var lspCompletionSnippet_js_1 = require("./snippet/lspCompletionSnippet.js");
// https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#textDocument_completion
function getGherkinCompletionItems(gherkinSource, position, index) {
    var stepRange = (0, helpers_js_1.getStepRange)(gherkinSource, position);
    if (!stepRange)
        return [];
    var suggestions = index(stepRange.stepText);
    // https://github.com/microsoft/language-server-protocol/issues/898#issuecomment-593968008
    return suggestions.map(function (suggestion, i) {
        // The index has already sorted the syggestions by match score.
        // We're moving suggestions that are from undefined steps to the bottom
        var sortText = (suggestion.matched ? i + 1000 : i + 2000).toString();
        var item = {
            label: suggestion.label,
            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
            kind: vscode_languageserver_types_1.CompletionItemKind.Text,
            labelDetails: __assign({}, (suggestion.matched ? {} : { detail: ' (undefined step)' })),
            // VSCode will only display suggestions that literally match the label.
            // We're overriding this behaviour by setting filterText to what the user has typed,
            // so that the suggestions are always displayed
            filterText: stepRange.stepText,
            sortText: sortText,
            textEdit: {
                newText: (0, lspCompletionSnippet_js_1.lspCompletionSnippet)(suggestion.segments),
                range: stepRange.range,
            },
        };
        return item;
    });
}
exports.getGherkinCompletionItems = getGherkinCompletionItems;
//# sourceMappingURL=getGherkinCompletionItems.js.map