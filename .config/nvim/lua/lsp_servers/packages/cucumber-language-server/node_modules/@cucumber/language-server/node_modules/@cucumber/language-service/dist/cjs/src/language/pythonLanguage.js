"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pythonLanguage = void 0;
exports.pythonLanguage = {
    toParameterTypeName: function (node) {
        switch (node.type) {
            case 'string': {
                return stringLiteral(node);
            }
            case 'concatednated_string': {
                return stringLiteral(node);
            }
            case 'identifier': {
                return node.text;
            }
            default: {
                throw new Error("Unsupported node type ".concat(node.type));
            }
        }
    },
    toParameterTypeRegExps: function (node) {
        return RegExp(cleanRegex(stringLiteral(node)));
    },
    toStepDefinitionExpression: function (node) {
        // this removes the head and tail apostrophes
        // remove python named capture groups.
        // TODO: This should be temporary. Python supports
        // a wider array of regex features than javascript
        // a singular way of communicating regex consistent
        // across languages is necessary
        return isRegex(node.text.slice(1, -1))
            ? RegExp(cleanRegex(node.text.slice(1, -1).split('?P').join('')))
            : node.text.slice(1, -1);
    },
    defineParameterTypeQueries: [
        "(call\n      arguments: (argument_list\n        (keyword_argument\n          name: (identifier) @name-key\n          value: (string) @name\n          (#eq? @name-key \"name\")\n        )?\n        (keyword_argument\n          name: (identifier) @regexp-key\n          value: (string) @expression\n          (#eq? @regexp-key \"regexp\")\n        )?\n        (keyword_argument\n          name: (identifier) @regexp-key\n          value: (concatenated_string) @expression\n          (#eq? @regexp-key \"regexp\")\n        )?\n     ))@root",
    ],
    defineStepDefinitionQueries: [
        "\n    (decorated_definition\n        (decorator\n            (call\n                function: (identifier) @method\n                arguments: (argument_list (string) @expression)\n            )\n        )\n        (#match? @method \"(given|when|then)\")\n    ) @root\n",
    ],
    snippetParameters: {
        int: { type: 'int' },
        float: { type: 'float' },
        word: { type: 'str' },
        string: { type: 'str' },
        double: { type: 'double' },
        bigdecimal: { type: 'decimal' },
        byte: { type: 'byte' },
        short: { type: 'short' },
        long: { type: 'long' },
        biginteger: { type: 'int' },
        '': { type: 'Object', name: 'arg' },
    },
    defaultSnippetTemplate: "\n  @{{ #lowercase }}{{ keyword }}{{ /lowercase }}('{{ expression }}')\n  def step_{{ #lowercase }}{{ keyword }}{{ /lowercase }}(context, {{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}{{ /parameters }}) :\n      # This was autogenerated using cucumber syntax.\n      # Please convert to use regular expressions, as Behave does not currently support Cucumber Expressions",
};
function cleanRegex(regexString) {
    var startsWith = regexString[0];
    switch (startsWith) {
        case '/':
            return regexString.slice(1, -1);
        default:
            return regexString;
    }
}
function stringLiteral(node) {
    var isFString = node.text.startsWith('f');
    var cleanWord = isFString ? node.text.slice(1).slice(1, -1) : node.text.slice(1, -1);
    return cleanWord;
}
function isRegex(cleanWord) {
    var startsWithSlash = cleanWord.startsWith('/');
    var namedGroupMatch = /\?P/;
    var containsNamedGroups = namedGroupMatch.test(cleanWord);
    return startsWithSlash || containsNamedGroups;
}
//# sourceMappingURL=pythonLanguage.js.map