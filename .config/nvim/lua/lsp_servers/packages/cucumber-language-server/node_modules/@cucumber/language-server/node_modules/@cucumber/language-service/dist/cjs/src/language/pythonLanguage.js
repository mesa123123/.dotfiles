"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegExp = exports.stringLiteral = exports.concatStringLiteral = exports.toStringOrRegExp = exports.pythonLanguage = void 0;
exports.pythonLanguage = {
    toParameterTypeName: function (node) {
        switch (node.type) {
            case 'string': {
                return stringLiteral(node.text);
            }
            case 'concatenated_string': {
                return concatStringLiteral(node.text);
            }
            case 'identifier': {
                return node.text;
            }
            default: {
                throw new Error("Unsupported node type ".concat(node.type));
            }
        }
    },
    toParameterTypeRegExps: function (node) {
        switch (node.type) {
            case 'string': {
                return RegExp(cleanRegExp(stringLiteral(node.text)));
            }
            case 'concatenated_string': {
                return RegExp(cleanRegExp(concatStringLiteral(node.text)));
            }
            case 'identifier': {
                return RegExp(cleanRegExp(stringLiteral(node.text)));
            }
            default: {
                throw new Error("Unsupported node type ".concat(node.type));
            }
        }
    },
    toStepDefinitionExpression: function (node) {
        // This removes the head and tail apostrophes.
        // TODO: This should be temporary. Python supports
        // a wider array of regex features than javascript
        // a singular way of communicating regex consistent
        // across languages is necessary
        return toStringOrRegExp(node.text);
    },
    defineParameterTypeQueries: [
        "(call\n      arguments: (argument_list\n        (keyword_argument\n          name: (identifier) @name-key\n          value: (string) @name\n          (#eq? @name-key \"name\")\n        )?\n        (keyword_argument\n          name: (identifier) @regexp-key\n          value: (string) @expression\n          (#eq? @regexp-key \"regexp\")\n        )?\n        (keyword_argument\n          name: (identifier) @regexp-key\n          value: (concatenated_string) @expression\n          (#eq? @regexp-key \"regexp\")\n        )?\n     ))@root",
    ],
    defineStepDefinitionQueries: [
        "\n    (decorated_definition\n      (decorator\n        (call\n          function: (identifier) @method\n          arguments: (argument_list (string) @expression)\n        )\n      )\n      (#match? @method \"(given|when|then)\")\n    ) @root\n",
    ],
    snippetParameters: {
        int: { type: 'int' },
        float: { type: 'float' },
        word: { type: 'str' },
        string: { type: 'str' },
        double: { type: 'double' },
        bigdecimal: { type: 'decimal' },
        byte: { type: 'byte' },
        short: { type: 'short' },
        long: { type: 'long' },
        biginteger: { type: 'int' },
        '': { type: 'Object', name: 'arg' },
    },
    defaultSnippetTemplate: "\n  @{{ #lowercase }}{{ keyword }}{{ /lowercase }}('{{ expression }}')\n  def step_{{ #lowercase }}{{ keyword }}{{ /lowercase }}(context, {{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}{{ /parameters }}) :\n      # This was autogenerated using cucumber syntax.\n      # Please convert to use regular expressions, as Behave does not currently support Cucumber Expressions",
};
function cleanRegExp(regExpString) {
    var startsWith = regExpString[0];
    switch (startsWith) {
        case '/':
            return regExpString.slice(1, -1);
        default:
            return regExpString;
    }
}
function toStringOrRegExp(step) {
    return isRegExp(step.slice(1, -1))
        ? RegExp(cleanRegExp(step.slice(1, -1).split('?P').join('')))
        : step.slice(1, -1);
}
exports.toStringOrRegExp = toStringOrRegExp;
function concatStringLiteral(text) {
    var isFString = text.startsWith('f');
    var cleanWord = isFString ? text.slice(1) : text;
    var postSplitCleanWord = cleanWord
        .split('\\\n')
        .map(function (x) { return x.replace(/"/g, ''); })
        .map(function (x) { return x.trim(); })
        .join('');
    return postSplitCleanWord;
}
exports.concatStringLiteral = concatStringLiteral;
function stringLiteral(text) {
    var isFString = text.startsWith('f');
    var cleanWord = isFString ? text.slice(1).slice(1, -1) : text.slice(1, -1);
    return cleanWord;
}
exports.stringLiteral = stringLiteral;
function isRegExp(cleanWord) {
    var startsWithSlash = cleanWord.startsWith('/');
    var namedGroupMatch = /\?P/;
    var specialCharsMatch = /\(|\)|\.|\*|\\|\|/;
    var containsNamedGroups = namedGroupMatch.test(cleanWord);
    var containsSpecialChars = specialCharsMatch.test(cleanWord);
    return startsWithSlash || containsNamedGroups || containsSpecialChars;
}
exports.isRegExp = isRegExp;
//# sourceMappingURL=pythonLanguage.js.map