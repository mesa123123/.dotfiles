"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringLiteral = exports.javaLanguage = void 0;
exports.javaLanguage = {
    toParameterTypeName: function (node) {
        switch (node.type) {
            case 'string_literal': {
                return stringLiteral(node);
            }
            case 'identifier': {
                return node.text;
            }
            default: {
                throw new Error("Unsupported node type ".concat(node.type));
            }
        }
    },
    toParameterTypeRegExps: function (node) {
        return stringLiteral(node);
    },
    toStepDefinitionExpression: function (node) {
        var text = stringLiteral(node);
        var hasRegExpAnchors = text[0] == '^' || text[text.length - 1] == '$';
        return hasRegExpAnchors ? new RegExp(text) : text;
    },
    defineParameterTypeQueries: [
        "\n(method_declaration \n  (modifiers \n    (annotation \n      name: (identifier) @annotation-name \n      arguments: (annotation_argument_list\n        [\n          (string_literal) @expression\n        ]\n      )\n    )\n  )\n  name: (identifier) @name\n  (#eq? @annotation-name \"ParameterType\")\n) @root\n    ",
        "\n(method_declaration \n  (modifiers \n    (annotation \n      name: (identifier) @annotation-name \n      arguments: (annotation_argument_list\n        [\n          (\n            (element_value_pair\n              key: (identifier) @name-key\n              value: (string_literal) @name\n            )\n            (element_value_pair\n              key: (identifier) @value-key\n              value: (string_literal) @expression\n            )\n          )\n          (\n            (element_value_pair\n              key: (identifier) @value-key\n              value: (string_literal) @expression\n            )\n            (element_value_pair\n              key: (identifier) @name-key\n              value: (string_literal) @name\n            )\n          )\n        ]\n      )\n    )\n  )\n  (#eq? @annotation-name \"ParameterType\")\n  (#eq? @name-key \"name\")\n  (#eq? @value-key \"value\")\n) @root\n",
    ],
    defineStepDefinitionQueries: [
        "\n(method_declaration \n  (modifiers \n    (annotation \n      name: (identifier) @annotation-name \n      arguments: (annotation_argument_list\n        [\n          (string_literal) @expression\n        ]\n      )\n    )\n  )\n  (#match? @annotation-name \"Given|When|Then\")\n) @root\n",
    ],
    snippetParameters: {
        int: { type: 'int', name: 'i' },
        float: { type: 'float', name: 'f' },
        word: { type: 'String' },
        string: { type: 'String', name: 's' },
        double: { type: 'double', name: 'd' },
        bigdecimal: { type: 'java.math.BigDecimal', name: 'bigDecimal' },
        byte: { type: 'byte', name: 'b' },
        short: { type: 'short', name: 's' },
        long: { type: 'long', name: 'l' },
        biginteger: { type: 'java.math.BigInteger', name: 'bigInteger' },
        '': { type: 'Object', name: 'arg' },
    },
    defaultSnippetTemplate: "\n    @{{ keyword }}(\"{{ expression }}\")\n    public void {{ #underscore }}{{ expression }}{{ /underscore }}({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ type }} {{ name }}{{ /parameters }}) {\n        // {{ blurb }}\n    }\n",
};
function stringLiteral(node) {
    if (node === null)
        throw new Error('node cannot be null');
    var string = node.text.slice(1, -1);
    return unescapeString(string.replace('(?i)', ''));
}
exports.stringLiteral = stringLiteral;
// Java escapes \ as \\. Turn \\ back to \.
function unescapeString(s) {
    return s.replace(/\\\\/g, '\\');
}
//# sourceMappingURL=javaLanguage.js.map