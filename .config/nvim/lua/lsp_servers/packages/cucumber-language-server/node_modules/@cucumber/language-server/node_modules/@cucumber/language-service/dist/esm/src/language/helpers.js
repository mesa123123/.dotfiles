import { ParameterType } from '@cucumber/cucumber-expressions';
import { Range } from 'vscode-languageserver-types';
export function syntaxNode(match, name) {
    const nodes = syntaxNodes(match, name);
    if (nodes.length > 1)
        throw new Error(`Expected exactly one node, but got ${nodes.map((node) => node.text)}`);
    return nodes[0] || null;
}
function syntaxNodes(match, name) {
    return match.captures.filter((c) => c.name === name).map((capture) => capture.node);
}
export function makeParameterType(name, regexps) {
    return new ParameterType(name, regexps, Object, (arg) => arg, true, false);
}
export function sortLinks(links) {
    return links.sort((a, b) => {
        const pathComparison = a.locationLink.targetUri.localeCompare(b.locationLink.targetUri);
        if (pathComparison !== 0)
            return pathComparison;
        return a.locationLink.targetRange.start.line - b.locationLink.targetRange.start.line;
    });
}
export function createLocationLink(rootNode, selectionNode, targetUri) {
    const targetRange = Range.create(rootNode.startPosition.row, rootNode.startPosition.column, rootNode.endPosition.row, rootNode.endPosition.column);
    const targetSelectionRange = Range.create(selectionNode.startPosition.row, selectionNode.startPosition.column, selectionNode.endPosition.row, selectionNode.endPosition.column);
    const locationLink = {
        targetRange,
        targetSelectionRange,
        targetUri,
    };
    return locationLink;
}
export function childrenToString(node, stringNodes) {
    return node.children
        .filter(stringNodes)
        .map((node) => node.text)
        .join('');
}
export const NO_QUOTES = (child) => child.type !== '"' && child.type !== "'";
export function filter(node, predicate) {
    return flatten(node).filter(predicate);
}
function flatten(node) {
    return node.children.reduce((r, o) => [...r, ...flatten(o)], [node]);
}
//# sourceMappingURL=helpers.js.map