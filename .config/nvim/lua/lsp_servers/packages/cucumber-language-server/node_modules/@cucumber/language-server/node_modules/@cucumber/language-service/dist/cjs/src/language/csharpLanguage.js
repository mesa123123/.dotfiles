"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.csharpLanguage = void 0;
var helpers_js_1 = require("./helpers.js");
exports.csharpLanguage = {
    toParameterTypeName: function (node) {
        switch (node.type) {
            case 'identifier': {
                return node.text;
            }
        }
        return (0, helpers_js_1.childrenToString)(node, helpers_js_1.NO_QUOTES);
    },
    toParameterTypeRegExps: function (node) {
        if (node === null) {
            return /.*/;
        }
        switch (node.type) {
            case 'verbatim_string_literal': {
                var s = node.text.slice(2, -1);
                return new RegExp(unescapeVerbatimString(s));
            }
            case 'string_literal': {
                var s = node.text.slice(1, -1);
                return new RegExp(unescapeString(s));
            }
            default:
                throw new Error("Unexpected type: ".concat(node.type));
        }
    },
    toStepDefinitionExpression: function (node) {
        switch (node.type) {
            case 'verbatim_string_literal': {
                var s = node.text.slice(2, -1);
                return new RegExp(unescapeVerbatimString(s));
            }
            case 'string_literal': {
                return unescapeString(node.text.slice(1, -1));
            }
            default:
                throw new Error("Unexpected type: ".concat(node.type));
        }
    },
    defineParameterTypeQueries: [
        "\n    (method_declaration\n      (attribute_list\n        (attribute\n          name: (identifier) @attribute-name\n          (attribute_argument_list\n            (attribute_argument\n              [\n                (verbatim_string_literal) \n                (string_literal)\n              ] @expression\n            )\n          )?\n        )\n      )\n      type: (identifier) @name\n      (#eq? @attribute-name \"StepArgumentTransformation\")\n    ) @root\n    ",
    ],
    defineStepDefinitionQueries: [
        "\n(method_declaration\n  (attribute_list\n    (attribute\n      name: (identifier) @annotation-name\n      (attribute_argument_list\n        (attribute_argument\n          (verbatim_string_literal) @expression\n        )\n      )\n    )\n  )\n  (#match? @annotation-name \"Given|When|Then|And|But|StepDefinition\")\n) @root\n",
        "\n(method_declaration\n  (attribute_list\n    (attribute\n      name: (identifier) @annotation-name\n      (attribute_argument_list\n        (attribute_argument\n          (string_literal) @expression\n        )\n      )\n    )\n  )\n  (#match? @annotation-name \"Given|When|Then|And|But|StepDefinition\")\n) @root\n",
    ],
    snippetParameters: {
        int: { type: 'int', name: 'i' },
        float: { type: 'float', name: 'f' },
        word: { type: 'string' },
        string: { type: 'string', name: 's' },
        double: { type: 'double', name: 'd' },
        bigdecimal: { type: 'BigDecimal', name: 'bigDecimal' },
        byte: { type: 'byte', name: 'b' },
        short: { type: 'short', name: 's' },
        long: { type: 'long', name: 'l' },
        biginteger: { type: 'BigInteger', name: 'bigInteger' },
        '': { type: 'object', name: 'arg' },
    },
    defaultSnippetTemplate: "\n    // This step definition uses Cucumber Expressions. See https://github.com/gasparnagy/CucumberExpressions.SpecFlow\n    [{{ keyword }}(\"{{ expression }}\")]\n    public void {{ #capitalize }}{{ #camelize }}{{ keyword }} {{expression}}{{ /camelize }}{{ /capitalize }}({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ type }} {{ name }}{{ /parameters }})\n    {\n        // {{ blurb }}\n    }\n",
};
// C# verbatim strings escape " as "". Unescape "" back to ".
// https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/verbatim
function unescapeVerbatimString(s) {
    return s.replace(/""/g, '"');
}
// TODO(@aslakhellesoy) not sure if this is correct.
function unescapeString(s) {
    return s.replace(/\\\\/g, '\\');
}
//# sourceMappingURL=csharpLanguage.js.map